<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FarSend - Private Batch Sender</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.3/dist/confetti.browser.min.js"></script>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">

    <meta name="fc:miniapp" content='{
      "version":"1",
      "imageUrl":"https://farsend.vercel.app/image.png",
      "button":{
        "title":"FarSend",
        "action":{
          "type":"launch_miniapp",
          "name":"FarSend",
          "url":"https://farsend.vercel.app",
          "splashImageUrl":"https://farsend.vercel.app/splash.png",
          "splashBackgroundColor":"#6A3CFF"
        }
      }
    }'>

    <style>
        :root {
            --fc-primary: linear-gradient(90deg, #6A3CFF, #A26BFF);
            --fc-primary-hover: linear-gradient(90deg, #582FD6, #8B5CF6);
            --fc-light-bg: #F3EFFF;
            --fc-text: #1F2937;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: #f9fafb;
        }

        .main-card {
            background-color: #ffffff;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.08);
            border: 1px solid #E5E7EB;
        }

        .btn-primary {
            background: var(--fc-primary);
            box-shadow: 0 4px 15px rgba(106, 60, 255, 0.4);
            color: white;
        }
        .btn-primary:hover {
            background: var(--fc-primary-hover);
            box-shadow: 0 0 12px rgba(162, 107, 255, 0.6);
        }
        .btn-primary:disabled {
            background: #E5E7EB;
            color: #9CA3AF;
            cursor: not-allowed;
            opacity: 1;
            box-shadow: none;
        }
        
        .input-focus:focus {
            border-color: #6A3CFF !important;
            box-shadow: 0 0 12px rgba(106, 60, 255, 0.4) !important;
            transition: box-shadow 0.2s ease;
        }

        textarea::-webkit-scrollbar, .overflow-auto::-webkit-scrollbar { width: 8px; }
        textarea::-webkit-scrollbar-track, .overflow-auto::-webkit-scrollbar-track { background: #F3F4F6; }
        textarea::-webkit-scrollbar-thumb, .overflow-auto::-webkit-scrollbar-thumb { background: #6A3CFF; border-radius: 10px; }
        textarea::-webkit-scrollbar-thumb:hover, .overflow-auto::-webkit-scrollbar-thumb:hover { background: #582FD6; }

        #notification {
            transition: opacity 0.5s ease, transform 0.5s ease;
            opacity: 0;
            transform: translateY(20px);
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(20px);
            z-index: 50;
        }
        #notification.show {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        @keyframes gradient-x {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }
        .animate-gradient-x {
            background-size: 200% 200%;
            animation: gradient-x 6s ease infinite;
        }

        #stepIndicator .flex-1.h-0\.5.bg-gray-200.mt-4.mx-2 {
            background: var(--fc-primary);
        }
    </style>
</head>
<body class="text-gray-900 min-h-screen flex items-center justify-center p-4">
    <div class="w-full max-w-2xl mx-auto">
        <header class="text-center mb-8">
            <div class="flex justify-center items-center mb-2">
                <h1 class="text-5xl font-extrabold tracking-tight bg-gradient-to-r from-[#6A3CFF] via-[#A26BFF] to-[#00E7FF] text-transparent bg-clip-text animate-gradient-x">FarSend</h1>
            </div>
            <p class="text-gray-600 mt-2">Send ETH & ERC-20s to multiple addresses, securely on Base.</p>
        </header>

        <main class="main-card rounded-2xl p-6 md:p-8 space-y-6">
            <div id="stepIndicator" class="flex justify-between items-start mb-8 pb-4 border-b border-gray-100">
                <div class="flex flex-col items-center flex-1 min-w-0">
                    <div id="stepCircle1" class="w-8 h-8 flex items-center justify-center rounded-full transition-all duration-300" style="background-color: #6A3CFF; color: white; border-color: #6A3CFF; ring-color: #6A3CFF;">
                        <span class="font-bold">1</span>
                    </div>
                    <span id="stepLabel1" class="text-xs mt-2 text-center font-semibold" style="color: #6A3CFF;">Connect Wallet</span>
                </div>
                <div class="flex-1 h-0.5 bg-gray-200 mt-4 mx-2"></div>
                
                <div class="flex flex-col items-center flex-1 min-w-0">
                    <div id="stepCircle2" class="w-8 h-8 flex items-center justify-center rounded-full bg-gray-200 text-gray-500 transition-all duration-300">
                        <span class="font-bold">2</span>
                    </div>
                    <span id="stepLabel2" class="text-xs mt-2 text-center text-gray-500">Define Recipients</span>
                </div>
                <div class="flex-1 h-0.5 bg-gray-200 mt-4 mx-2"></div>

                <div class="flex flex-col items-center flex-1 min-w-0">
                    <div id="stepCircle3" class="w-8 h-8 flex items-center justify-center rounded-full bg-gray-200 text-gray-500 transition-all duration-300">
                        <span class="font-bold">3</span>
                    </div>
                    <span id="stepLabel3" class="text-xs mt-2 text-center text-gray-500">Dispatch</span>
                </div>
            </div>
            
            <div class="flex flex-col space-y-3 py-2">
                <div class="flex justify-between items-center">
                    <h2 class="text-lg font-semibold text-gray-800">Wallet</h2>
                    <button id="connectWalletBtn" class="w-48 bg-gray-200 hover:bg-gray-300 text-gray-700 font-semibold py-2 px-4 rounded-lg transition-colors duration-300 flex items-center justify-center space-x-2">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 9V7a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2m2 4h10a2 2 0 002-2v-6a2 2 0 00-2-2H9a2 2 0 00-2 2v6a2 2 0 002 2zm7-5a2 2 0 11-4 0 2 2 0 014 0z"></path></svg>
                        <span>Connect Wallet</span>
                    </button>
                </div>
                <div class="flex justify-between items-center pt-2 border-t border-gray-100">
                    <h2 class="text-lg font-semibold text-gray-800">Farcaster ID (Optional)</h2>
                    <button id="farcasterConnectBtn" class="w-48 bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 px-4 rounded-lg transition-colors duration-300 flex items-center justify-center space-x-2 disabled:opacity-50 disabled:cursor-not-allowed">
                        <svg class="w-5 h-5" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M18.784 11.232c-.524-.717-1.12-1.385-1.782-2.003L12 3.12 7.004 9.172c-.662.618-1.258 1.286-1.782 2.003-.574.786-.872 1.696-.872 2.656 0 1.986.812 3.844 2.22 5.188 1.408 1.344 3.328 2.084 5.346 2.084 2.018 0 3.938-.74 5.346-2.084 1.408-1.344 2.22-3.202 2.22-5.188 0-.96-.298-1.87-.872-2.656zm-6.784 8.768c-1.334 0-2.586-.534-3.52-1.48s-1.48-2.186-1.48-3.52c0-.68.12-1.34.354-1.966.234-.626.586-1.206 1.054-1.724L12 6.072l6.596 6.54c.468.518.82 1.098 1.054 1.724.234.626.354 1.286.354 1.966 0 1.334-.534 2.586-1.48 3.52s-2.186 1.48-3.52 1.48z" fill="white"/></svg>
                        <span id="farcasterBtnText">Link Farcaster ID</span>
                    </button>
                </div>
            </div>
            
            <div id="app-content" class="hidden space-y-6">
                <div class="h-px bg-gray-100"></div>
                <div>
                    <h2 class="text-lg font-semibold text-gray-800 mb-4">Define Token & Recipients</h2>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div>
                            <label for="tokenSelect" class="block text-sm font-medium text-gray-600 mb-1">Asset Type</label>
                            <select id="tokenSelect" class="w-full bg-gray-50 border border-gray-300 rounded-lg p-2.5 input-focus outline-none transition duration-150">
                                <option value="ETH">ETH (on Base)</option>
                                <option value="ERC20">ERC-20 Token</option>
                            </select>
                        </div>
                        <div id="erc20InputContainer" class="hidden">
                            <label for="erc20Address" class="block text-sm font-medium text-gray-600 mb-1">Token Contract Address</label>
                            <div class="relative">
                                <input type="text" id="erc20Address" placeholder="0x..." class="w-full bg-gray-50 border border-gray-300 rounded-lg p-2.5 pr-20 input-focus outline-none transition duration-150">
                                <span id="tokenSymbolDisplay" class="absolute right-0 top-0 h-full flex items-center pr-3 text-xs text-gray-500 font-medium"></span>
                            </div>
                        </div>
                    </div>
                    <div class="mt-6">
                        <label for="recipients" class="block text-sm font-medium text-gray-600 mb-1">Recipients & Amounts</label>
                        <textarea id="recipients" rows="6" class="w-full bg-gray-50 border border-gray-300 rounded-lg p-3 text-sm input-focus outline-none transition duration-150 text-gray-900" placeholder="Enter one address and amount per line, separated by a comma or space.&#10;e.g.,&#10;0xAb5801a7D398351b8bE11C439e05C5B3259aeC9B, 1.5&#10;0x5B38Da6a701c568545dCfcB03FcB875f56beddC4 10.75"></textarea>
                        <div class="flex justify-end text-xs text-gray-500 mt-2 space-x-4">
                            <a href="#" id="exportListBtn" class="cursor-pointer font-medium hover:underline" style="color: #6A3CFF;">Export List (.csv)</a>
                            <span>Or, <label for="csvUpload" class="cursor-pointer font-medium hover:underline" style="color: #6A3CFF;">upload a file</label></span>
                            <input type="file" id="csvUpload" class="hidden" accept=".csv, .txt, .json">
                        </div>
                    </div>
                    <div id="dataPreview" class="hidden mt-4">
                        <h4 class="text-sm font-medium text-gray-600 mb-2">Data Preview</h4>
                        <div class="main-card rounded-lg p-3 max-h-32 overflow-auto text-xs border border-gray-200">
                            <table class="w-full">
                                <thead>
                                    <tr class="text-left text-gray-500 sticky top-0 bg-white">
                                        <th class="p-1 font-semibold">Address</th>
                                        <th class="p-1 font-semibold text-right">Amount</th>
                                    </tr>
                                </thead>
                                <tbody id="previewTableBody" class="text-gray-800"></tbody>
                            </table>
                        </div>
                        <p id="previewFooter" class="text-xs text-gray-500 mt-2 hidden"></p>
                    </div>
                </div>
                <div class="h-px bg-gray-100"></div>
                <div id="approvalSection" class="p-4 bg-yellow-50 rounded-lg border border-yellow-200 hidden">
                    <p class="text-sm text-yellow-800 mb-3 font-semibold flex items-center">
                        <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path></svg>
                        Token Approval Required
                    </p>
                    <p id="approvalMessage" class="text-sm text-yellow-700"></p>
                    <button id="approveBtn" class="w-full mt-3 bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-2 px-4 rounded-lg transition-colors duration-300">
                        Approve <span id="approveAmount">0.00</span> <span id="approveSymbol">Token</span>
                    </button>
                </div>
                <div id="dispatchSection">
                    <h2 class="text-lg font-semibold text-gray-800 mb-3">Review & Dispatch</h2>
                    <div class="bg-gray-50 rounded-lg p-4 space-y-3 text-sm border border-gray-200">
                        <div class="flex justify-between items-center">
                            <span class="text-gray-600">Total Recipients:</span>
                            <span id="recipientCount" class="font-mono font-bold text-gray-900">0</span>
                        </div>
                        <div class="flex justify-between items-center">
                            <span class="text-gray-600">Total Amount:</span>
                            <span id="totalAmount" class="font-mono font-bold text-gray-900">0.00</span>
                        </div>
                        <div id="tokenInfoRow" class="hidden flex justify-between items-center">
                            <span class="text-gray-600">Token Contract:</span>
                            <span id="tokenContractDisplay" class="font-mono text-xs font-bold text-gray-900"></span>
                        </div>
                        <div class="flex justify-between items-center pt-2 border-t border-gray-100">
                            <span class="text-gray-600">Transaction Type:</span>
                            <span class="font-bold text-gray-900">Batch Send</span>
                        </div>
                    </div>
                    <button id="dispatchBtn" disabled class="w-full mt-6 btn-primary font-bold py-3 px-4 rounded-lg transition-transform transform hover:scale-[1.01] duration-300 flex items-center justify-center space-x-3">
                        <svg id="shieldIcon" class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 20.944A12.02 12.02 0 0012 22a12.02 12.02 0 009-1.056h.001c.34.34.71.656 1.088.943l.044.032c.29.213.636.35.995.396V20.944c0-2.042-.393-4.005-1.12-5.786z"></path></svg>
                        <span id="dispatchBtnText">Dispatch Batch</span>
                        <div id="loadingSpinner" class="hidden animate-spin rounded-full h-5 w-5 border-b-2 border-white"></div>
                    </button>
                    <p class="text-xs text-center text-gray-500 mt-2">Transactions are processed on-chain (publicly transparent).</p>
                    <p class="text-xs text-center text-gray-500 mt-2">Privacy: Standard transparency (public on-chain). FHE privacy layer coming Q1 2026 when Zama Protocol expands to Base. Try Zama FHE Sepolia testnet <a href="https://farsend.vercel.app/sepolia" target="_blank" class="underline" style="color: #6A3CFF;">here</a>.</p>
                </div>
            </div>
        </main>
        <footer class="text-center text-sm mt-8 bg-gradient-to-r from-[#6A3CFF] to-[#A26BFF] text-white p-4 rounded-lg shadow-md">
            <p>Built for the Farcaster + Base ecosystem.</p>
            <p><a href="https://farcaster.xyz/dare1.eth" target="_blank" class="underline">dare1.eth</a></p>
            <p>&copy; 2025 FarSend</p>
        </footer>
    </div>
    <div id="notification" class="p-4 rounded-lg text-sm main-card shadow-lg" style="border: 1px solid #A98EFF;"></div>
    <script type="module">
      import { sdk } from 'https://esm.sh/@farcaster/miniapp-sdk';
      sdk.actions.ready({ disableNativeGestures: true });
    </script>
    <script type="module">
      import {
        createConfig,
        connect,
        disconnect,
        writeContract,
        readContract,
        http,
        waitForTransactionReceipt,
        watchAccount
      } from 'https://esm.sh/@wagmi/core';
      import { base } from 'https://esm.sh/@wagmi/core/chains';
      import { farcasterMiniApp } from 'https://esm.sh/@farcaster/miniapp-wagmi-connector';
      import { injected, walletConnect } from 'https://esm.sh/@wagmi/connectors';
      import { createPublicClient, parseEther, parseUnits, getAddress, decodeErrorResult, toUtf8String } from 'https://esm.sh/viem';
      import { formatUnits } from 'https://esm.sh/ethers';

      window.addEventListener('load', async () => {
          (async () => {
              const BASE_CHAIN_ID = 8453;
              const BASE_EXPLORER_URL = 'https://basescan.org';
              const WALLETCONNECT_PROJECT_ID = 'e0dd881bad824ac3418617434a79f917';

              let CONTRACT_ADDRESS, CONTRACT_ABI;
              const cacheKey = 'farsend-base-config';
              const cached = localStorage.getItem(cacheKey);
              if (cached) {
                  try {
                      const cfg = JSON.parse(cached);
                      CONTRACT_ADDRESS = cfg.address;
                      CONTRACT_ABI = cfg.abi;
                      console.log('âœ… Loaded BaseBatchSender from cache:', CONTRACT_ADDRESS);
                  } catch (e) {
                      console.warn('Cache invalid, fetching fresh config');
                  }
              }
              if (!CONTRACT_ADDRESS) {
                  try {
                      const res = await fetch('base.json');
                      if (!res.ok) throw new Error(`HTTP ${res.status}: Failed to fetch base.json`);
                      const cfg = await res.json();
                      CONTRACT_ADDRESS = cfg.address;
                      CONTRACT_ABI = cfg.abi;
                      localStorage.setItem(cacheKey, JSON.stringify(cfg));
                      console.log('âœ… Loaded BaseBatchSender:', CONTRACT_ADDRESS);
                  } catch (e) {
                      console.error('âŒ Failed loading base.json:', e);
                      showNotification('Failed to load contract configuration. Please refresh.', 'error');
                  }
              }

              const publicClient = createPublicClient({
                  chain: base,
                  transport: http()
              });

              const ERC20_ABI = [
                  { "constant": true, "inputs": [], "name": "name", "outputs": [{ "name": "", "type": "string" }, { "name": "", "type": "bytes32" }], "type": "function" },
                  { "constant": true, "inputs": [], "name": "symbol", "outputs": [{ "name": "", "type": "string" }, { "name": "", "type": "bytes32" }], "type": "function" },
                  { "constant": true, "inputs": [], "name": "decimals", "outputs": [{ "name": "", "type": "uint8" }], "type": "function" },
                  { "constant": true, "inputs": [{ "name": "owner", "type": "address" }, { "name": "spender", "type": "address" }], "name": "allowance", "outputs": [{ "name": "", "type": "uint256" }], "type": "function" },
                  { "constant": false, "inputs": [{ "name": "spender", "type": "address" }, { "name": "amount", "type": "uint256" }], "name": "approve", "outputs": [{ "name": "", "type": "bool" }], "type": "function" }
              ];

              let isMiniApp = false;
              let farcasterSdk;
              try {
                  farcasterSdk = sdk;
                  if (farcasterSdk && typeof farcasterSdk.actions.ready === 'function') {
                      isMiniApp = true;
                      console.log('âœ… Running in Farcaster Mini App');
                  }
              } catch (e) {
                  console.log('Not in Farcaster Mini App');
              }

              if (isMiniApp) {
                  const hasPromptedAddApp = sessionStorage.getItem('hasPromptedAddApp');
                  if (!hasPromptedAddApp && farcasterSdk?.actions?.addMiniApp) {
                      try {
                          await farcasterSdk.actions.addMiniApp();
                          sessionStorage.setItem('hasPromptedAddApp', 'true');
                          showNotification('FarSend Mini App added to Farcaster!', 'success');
                      } catch (error) {
                          console.error('Failed to prompt addMiniApp:', error);
                          showNotification('Failed to add Mini App to Farcaster.', 'error');
                      }
                  }
              }

              const metadata = {
                  name: 'FarSend',
                  description: 'Private Batch Sender on Base.',
                  url: 'https://farsend.vercel.app',
                  icons: ['https://farsend.vercel.app/image.png'],
              };

              const wagmiConfig = createConfig({
                  autoConnect: false,
                  chains: [base],
                  connectors: [
                      farcasterMiniApp(farcasterSdk),
                      injected({}),
                      walletConnect({
                          projectId: WALLETCONNECT_PROJECT_ID,
                          metadata,
                          showQrModal: false
                      })
                  ],
                  transports: {
                      [base.id]: http(),
                  },
              });

              const connectWalletBtn = document.getElementById('connectWalletBtn');
              const farcasterConnectBtn = document.getElementById('farcasterConnectBtn');
              const appContent = document.getElementById('app-content');
              const tokenSelect = document.getElementById('tokenSelect');
              const erc20InputContainer = document.getElementById('erc20InputContainer');
              const erc20Address = document.getElementById('erc20Address');
              const tokenSymbolDisplay = document.getElementById('tokenSymbolDisplay');
              const recipientsTextarea = document.getElementById('recipients');
              const csvUpload = document.getElementById('csvUpload');
              const recipientCountEl = document.getElementById('recipientCount');
              const totalAmountEl = document.getElementById('totalAmount');
              const tokenContractDisplay = document.getElementById('tokenContractDisplay');
              const tokenInfoRow = document.getElementById('tokenInfoRow');
              const dispatchBtn = document.getElementById('dispatchBtn');
              const dispatchBtnText = document.getElementById('dispatchBtnText');
              const loadingSpinner = document.getElementById('loadingSpinner');
              const notification = document.getElementById('notification');
              const approvalSection = document.getElementById('approvalSection');
              const approveBtn = document.getElementById('approveBtn');
              const approvalMessage = document.getElementById('approvalMessage');
              const approveAmountEl = document.getElementById('approveAmount');
              const approveSymbolEl = document.getElementById('approveSymbol');

              let isConnecting = false;
              const state = {
                  isWalletConnected: false,
                  walletAddress: null,
                  batchContract: CONTRACT_ADDRESS ? { address: CONTRACT_ADDRESS, abi: CONTRACT_ABI } : null,
                  recipients: [],
                  token: 'ETH',
                  tokenInfo: {
                      address: '',
                      symbol: 'ETH',
                      decimals: 18,
                      allowance: 0n,
                      requiredAllowance: 0n,
                  },
                  currentStep: 1,
              };

              function showNotification(message, type = 'success') {
                  const icons = { success: 'âœ…', error: 'âŒ', info: 'ðŸ’¡' };
                  notification.innerHTML = `${icons[type] || ''} ${message}`;
                  notification.className = 'p-4 rounded-lg text-sm main-card shadow-lg show';
                  if (type === 'success') {
                      notification.style.backgroundColor = '#d1fae5';
                      notification.style.color = '#065f46';
                      notification.style.border = '1px solid #34d399';
                  } else if (type === 'error') {
                      notification.style.backgroundColor = '#fee2e2';
                      notification.style.color = '#991b1b';
                      notification.style.border = '1px solid #f87171';
                  } else {
                      notification.style.backgroundColor = '#DBEAFE';
                      notification.style.color = '#1E40AF';
                      notification.style.border = '1px solid #93C5FD';
                  }
                  setTimeout(() => notification.classList.remove('show'), 8000);
              }

              function showAddress(userAddress) {
                  const truncatedAddress = `${userAddress.slice(0, 6)}...${userAddress.slice(-4)}`;
                  connectWalletBtn.innerHTML = `<span>Connected: ${truncatedAddress}</span>`;
                  connectWalletBtn.classList.remove('bg-gray-200', 'hover:bg-gray-300', 'text-gray-700');
                  connectWalletBtn.classList.add('bg-green-500', 'hover:bg-green-600', 'text-white');
                  showNotification(`Wallet connected on Base: ${truncatedAddress}`, 'success');
              }

              function updateStepIndicator(step) {
                  state.currentStep = step;
                  const steps = [
                      { id: 'stepCircle1', labelId: 'stepLabel1', label: 'Connect Wallet' },
                      { id: 'stepCircle2', labelId: 'stepLabel2', label: 'Define Recipients' },
                      { id: 'stepCircle3', labelId: 'stepLabel3', label: 'Dispatch' }
                  ];

                  steps.forEach((s, index) => {
                      const stepEl = document.getElementById(s.id);
                      const labelEl = document.getElementById(s.labelId);
                      const isActive = (index + 1) === step;
                      const isCompleted = (index + 1) < step;

                      stepEl.className = 'w-8 h-8 flex items-center justify-center rounded-full transition-all duration-300';
                      labelEl.className = 'text-xs mt-2 text-center transition-colors duration-300';
                      
                      if (isActive) {
                          stepEl.style.backgroundColor = '#6A3CFF';
                          stepEl.style.color = 'white';
                          stepEl.classList.add('ring-4', 'ring-opacity-50');
                          stepEl.style.setProperty('ring-color', '#6A3CFF');
                          labelEl.classList.add('font-semibold');
                          labelEl.style.color = '#6A3CFF';
                      } else if (isCompleted) {
                          stepEl.style.backgroundColor = 'var(--fc-light-bg)';
                          stepEl.style.color = '#6A3CFF';
                          stepEl.classList.remove('ring-4', 'ring-opacity-50');
                          labelEl.style.color = '#582FD6';
                          labelEl.classList.add('font-medium');
                      } else {
                          stepEl.style.backgroundColor = '#E5E7EB';
                          stepEl.style.color = '#6B7280';
                          stepEl.classList.remove('ring-4', 'ring-opacity-50');
                          labelEl.style.color = '#6B7280';
                          labelEl.classList.remove('font-semibold');
                      }
                  });
              }

              async function checkAndSwitchChain() {
                  const maxRetries = 3;
                  let attempt = 0;
                  while (attempt < maxRetries) {
                      try {
                          const chainId = wagmiConfig.state.chainId;
                          if (chainId !== BASE_CHAIN_ID) {
                              showNotification('Wallet is on the wrong network. Switching to Base Mainnet...', 'info');
                              await wagmiConfig.switchChain({ chainId: BASE_CHAIN_ID });
                              console.log('Switched to Base Mainnet');
                              return;
                          }
                          return;
                      } catch (error) {
                          attempt++;
                          if (attempt === maxRetries) {
                              showNotification('Please manually switch your wallet to Base Mainnet (Chain ID 8453).', 'error');
                              throw new Error('Wrong network');
                          }
                          console.warn(`Network switch attempt ${attempt} failed, retrying...`, error);
                          await new Promise(resolve => setTimeout(resolve, 1000));
                      }
                  }
              }

              async function handleConnect() {
                  if (isConnecting) return;
                  isConnecting = true;
                  
                  connectWalletBtn.disabled = true;
                  connectWalletBtn.innerHTML = `<span class="animate-pulse text-purple-700 font-bold">Connecting...</span>`;

                  let successfulConnection = false;
                  let lastError = null;

                  try {
                      let connector;
                      if (isMiniApp) {
                          connector = farcasterMiniApp(farcasterSdk);
                          console.log('Attempting connection with farcasterMiniApp');
                          const conn = await connect(wagmiConfig, { 
                              connector,
                              chainId: BASE_CHAIN_ID
                          });
                          state.walletAddress = conn.accounts[0];
                          await checkAndSwitchChain();
                          successfulConnection = true;
                          showAddress(state.walletAddress);
                      } else {
                          const connectorsToTry = [
                              wagmiConfig.connectors.find(c => c.id === 'injected'),
                              wagmiConfig.connectors.find(c => c.id === 'walletConnect')
                          ].filter(c => c);
                          
                          for (const conn of connectorsToTry) {
                              try {
                                  console.log(`Attempting connection with: ${conn.name || conn.id}`);
                                  const result = await connect(wagmiConfig, { 
                                      connector: conn,
                                      chainId: BASE_CHAIN_ID
                                  });
                                  state.walletAddress = result.accounts[0];
                                  await checkAndSwitchChain();
                                  successfulConnection = true;
                                  showAddress(state.walletAddress);
                                  break;
                              } catch (error) {
                                  console.error(`Connection with ${conn.name || conn.id} failed:`, error);
                                  lastError = error;
                                  if (conn.id === 'walletConnect' && error.shortMessage?.includes('rejected')) {
                                      break;
                                  }
                                  if (error.message?.includes('Wrong network')) {
                                      break;
                                  }
                              }
                          }
                      }

                      if (successfulConnection) {
                          state.isWalletConnected = true;
                          appContent.classList.remove('hidden');
                          farcasterConnectBtn.disabled = false;
                          updateStepIndicator(2);

                          watchAccount(wagmiConfig, {
                              onChange(account) {
                                  if (account.address && account.isConnected) {
                                      console.log('Account changed to:', account.address);
                                      state.walletAddress = account.address;
                                      showAddress(state.walletAddress);
                                      updateSummary();
                                  } else if (!account.isConnected && state.walletAddress) {
                                      handleDisconnect();
                                      showNotification('Wallet disconnected.', 'warning');
                                  }
                              }
                          });
                      } else {
                          throw lastError || new Error('No successful connection');
                      }

                  } catch (error) {
                      console.error('Connection failed:', error);
                      let msg = error.shortMessage || error.message || 'Connection failed or rejected.';
                      if (msg.includes('Wrong network')) {
                          msg = 'Please switch your wallet to Base Mainnet (Chain ID 8453).';
                      } else if (msg.includes('rejected')) {
                          msg = 'Connection request rejected by user.';
                      } else if (msg.includes('provider') || msg.includes('No wallet provider')) {
                          msg = 'No wallet provider detected. Please install MetaMask or use WalletConnect.';
                      }
                      showNotification(msg.length > 100 ? msg.substring(0, 100) + '...' : msg, 'error');
                      connectWalletBtn.innerHTML = `
                          <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 9V7a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2m2 4h10a2 2 0 002-2v-6a2 2 0 00-2-2H9a2 2 0 00-2 2v6a2 2 0 002 2zm7-5a2 2 0 11-4 0 2 2 0 014 0z"></path></svg>
                          <span>Connect Wallet</span>`;
                  } finally {
                      connectWalletBtn.disabled = false;
                      isConnecting = false;
                  }
              }

              async function handleDisconnect() {
                  try {
                      await disconnect(wagmiConfig);
                  } catch (error) {
                      console.error('Disconnect failed:', error);
                  }
                  state.isWalletConnected = false;
                  state.walletAddress = null;
                  state.tokenInfo = { address: '', symbol: 'ETH', decimals: 18, allowance: 0n, requiredAllowance: 0n };
                  erc20Address.value = '';
                  tokenSymbolDisplay.textContent = '';
                  approvalSection.classList.add('hidden');
                  connectWalletBtn.innerHTML = `
                      <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 9V7a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2m2 4h10a2 2 0 002-2v-6a2 2 0 00-2-2H9a2 2 0 00-2 2v6a2 2 0 002 2zm7-5a2 2 0 11-4 0 2 2 0 014 0z"></path></svg>
                      <span>Connect Wallet</span>`;
                  connectWalletBtn.classList.remove('bg-green-500', 'hover:bg-green-600', 'text-white');
                  connectWalletBtn.classList.add('bg-gray-200', 'hover:bg-gray-300', 'text-gray-700');
                  farcasterConnectBtn.disabled = true;
                  appContent.classList.add('hidden');
                  updateStepIndicator(1);
              }

              async function validateERC20Address(address) {
                  if (!address.startsWith('0x') || address.length !== 42) {
                      state.tokenInfo = { address: '', symbol: 'Invalid', decimals: 18, allowance: 0n, requiredAllowance: 0n };
                      tokenSymbolDisplay.textContent = 'Invalid';
                      tokenInfoRow.classList.add('hidden');
                      showNotification('Please enter a valid 42-character Ethereum address starting with 0x.', 'error');
                      return false;
                  }

                  tokenSymbolDisplay.textContent = 'Validating...';
                  tokenSymbolDisplay.classList.add('animate-pulse');
                  try {
                      const contractCode = await publicClient.getBytecode({ address });
                      if (!contractCode || contractCode === '0x') {
                          throw new Error('Address is not a deployed contract');
                      }

                      const tokenContract = { address: getAddress(address), abi: ERC20_ABI };
                      console.log('Validating ERC-20 contract at:', address);

                      const [symbolResult, decimals, nameResult] = await Promise.all([
                          readContract(wagmiConfig, { ...tokenContract, functionName: 'symbol' })
                              .catch(() => { throw new Error('Failed to read token symbol'); }),
                          readContract(wagmiConfig, { ...tokenContract, functionName: 'decimals' })
                              .catch(() => { throw new Error('Failed to read token decimals'); }),
                          readContract(wagmiConfig, { ...tokenContract, functionName: 'name' })
                              .catch(() => 'Unknown')
                      ]);

                      const symbol = typeof symbolResult === 'string' ? symbolResult : toUtf8String(symbolResult).replace(/\0/g, '');
                      const name = typeof nameResult === 'string' ? nameResult : toUtf8String(nameResult).replace(/\0/g, '');

                      if (!symbol || typeof decimals !== 'number' || decimals < 0 || decimals > 255) {
                          throw new Error('Contract does not support required ERC-20 functions');
                      }

                      state.tokenInfo = {
                          address: getAddress(address),
                          symbol,
                          name: name || symbol,
                          decimals: Number(decimals),
                          allowance: 0n,
                          requiredAllowance: 0n,
                      };

                      tokenSymbolDisplay.textContent = state.tokenInfo.symbol;
                      tokenContractDisplay.textContent = `${state.tokenInfo.address.slice(0, 6)}...${state.tokenInfo.address.slice(-4)}`;
                      tokenInfoRow.classList.remove('hidden');
                      showNotification(`Token validated: ${state.tokenInfo.name} (${state.tokenInfo.symbol}, ${state.tokenInfo.decimals} decimals)`, 'success');
                      await updateSummary();
                      return true;
                  } catch (error) {
                      console.error('ERC-20 validation failed:', error);
                      let errorMessage;
                      if (error.message.includes('not a deployed contract')) {
                          errorMessage = 'The provided address is not a deployed contract on Base.';
                      } else if (error.message.includes('symbol')) {
                          errorMessage = 'Failed to read token symbol. Ensure the contract is a valid ERC-20 token.';
                      } else if (error.message.includes('decimals')) {
                          errorMessage = 'Failed to read token decimals. Ensure the contract is a valid ERC-20 token.';
                      } else if (error.message.includes('network') || error.message.includes('provider')) {
                          errorMessage = 'Network error. Please check your connection or try again later.';
                      } else {
                          errorMessage = `Invalid ERC-20 contract: ${error.message || 'Unable to read contract data'}`;
                      }
                      state.tokenInfo = { address: '', symbol: 'Invalid', decimals: 18, allowance: 0n, requiredAllowance: 0n };
                      tokenSymbolDisplay.textContent = 'Invalid';
                      tokenInfoRow.classList.add('hidden');
                      showNotification(errorMessage, 'error');
                      return false;
                  } finally {
                      tokenSymbolDisplay.classList.remove('animate-pulse');
                  }
              }

              async function checkAndPromptApproval() {
                  if (state.token !== 'ERC20' || !state.tokenInfo.address || !CONTRACT_ADDRESS) {
                      approvalSection.classList.add('hidden');
                      return true;
                  }
                  const totalAmountDecimal = state.recipients.reduce((sum, r) => sum + r.amount, 0);
                  const totalAmountBN = parseUnits(totalAmountDecimal.toString(), state.tokenInfo.decimals);
                  state.tokenInfo.requiredAllowance = totalAmountBN;
                  try {
                      const allowance = await readContract(wagmiConfig, {
                          address: state.tokenInfo.address,
                          abi: ERC20_ABI,
                          functionName: 'allowance',
                          args: [state.walletAddress, CONTRACT_ADDRESS],
                      });
                      state.tokenInfo.allowance = allowance;
                      if (allowance >= totalAmountBN) {
                          approvalSection.classList.add('hidden');
                          return true;
                      } else {
                          const neededAmount = totalAmountBN - allowance;
                          const neededAmountFormatted = formatUnits(neededAmount, state.tokenInfo.decimals);
                          approveAmountEl.textContent = totalAmountDecimal.toFixed(state.tokenInfo.decimals > 4 ? 4 : state.tokenInfo.decimals);
                          approveSymbolEl.textContent = state.tokenInfo.symbol;
                          approvalMessage.textContent = `The batch sender requires approval to spend ${totalAmountDecimal.toFixed(4)} ${state.tokenInfo.symbol}. Your current allowance is insufficient.`;
                          approvalSection.classList.remove('hidden');
                          return false;
                      }
                  } catch (error) {
                      console.error('Allowance check failed:', error);
                      showNotification('Failed to check token allowance. Please ensure the token contract is valid and try again.', 'error');
                      return false;
                  }
              }

              async function handleApprove() {
                  if (!CONTRACT_ADDRESS) {
                      showNotification('Contract address not loaded. Please refresh.', 'error');
                      return;
                  }
                  approveBtn.disabled = true;
                  approveBtn.innerHTML = 'Approving...';
                  const amountToApprove = state.tokenInfo.requiredAllowance;
                  try {
                      showNotification(`Requesting approval for ${formatUnits(amountToApprove, state.tokenInfo.decimals)} ${state.tokenInfo.symbol}...`, 'info');
                      const txHash = await writeContract(wagmiConfig, {
                          address: state.tokenInfo.address,
                          abi: ERC20_ABI,
                          functionName: 'approve',
                          args: [CONTRACT_ADDRESS, amountToApprove],
                      });
                      showNotification(`Approval transaction sent: <a href="${BASE_EXPLORER_URL}/tx/${txHash}" target="_blank" class="font-bold underline" style="color: #582FD6;">View Tx</a>`, 'info');
                      await waitForTransactionReceipt(wagmiConfig, { hash: txHash });
                      showNotification(`Approval confirmed! You can now dispatch the batch.`, 'success');
                      state.tokenInfo.allowance = amountToApprove;
                      approvalSection.classList.add('hidden');
                      await updateSummary();
                  } catch (error) {
                      console.error('Approval failed:', error);
                      const msg = error.shortMessage?.includes('rejected') ? 'Transaction rejected by user.' : `Approval failed: ${error.shortMessage || error.message}`;
                      showNotification(msg, 'error');
                  } finally {
                      approveBtn.disabled = false;
                      approveBtn.innerHTML = `Approve <span id="approveAmount">${formatUnits(amountToApprove, state.tokenInfo.decimals)}</span> <span id="approveSymbol">${state.tokenInfo.symbol}</span>`;
                  }
              }

              async function handleDispatch() {
                  if (!state.walletAddress) return showNotification('Wallet not connected.', 'error');
                  if (!state.batchContract || !CONTRACT_ADDRESS) return showNotification('Batch contract not loaded. Please refresh the page.', 'error');
                  dispatchBtn.disabled = true;
                  loadingSpinner.classList.remove('hidden');
                  dispatchBtnText.textContent = 'Preparing batch...';
                  document.getElementById('shieldIcon').classList.add('hidden');
                  const { recipients, token, tokenInfo, batchContract, walletAddress } = state;
                  try {
                      if (recipients.length === 0) throw new Error('No recipients defined');
                      const decimals = token === 'ETH' ? 18 : tokenInfo.decimals;
                      const rawAmounts = recipients.map(r => r.amount.toString());
                      const amounts = rawAmounts.map(a => parseUnits(a, decimals));
                      const totalAmountBN = amounts.reduce((sum, amt) => sum + amt, 0n);
                      if (token === 'ETH') {
                          const balance = await publicClient.getBalance({ address: walletAddress });
                          if (totalAmountBN > balance) {
                              const required = formatUnits(totalAmountBN, 18);
                              const available = formatUnits(balance, 18);
                              throw new Error(`Insufficient ETH balance. Required: ${required} ETH, Available: ${available} ETH`);
                          }
                      } else {
                          if (!tokenInfo.address) throw new Error('Token contract not initialized');
                          const allowance = await readContract(wagmiConfig, {
                              address: tokenInfo.address,
                              abi: ERC20_ABI,
                              functionName: 'allowance',
                              args: [walletAddress, CONTRACT_ADDRESS],
                          });
                          if (allowance < totalAmountBN) {
                              const required = formatUnits(totalAmountBN, decimals);
                              const avail = formatUnits(allowance, decimals);
                              throw new Error(`Insufficient allowance for ${tokenInfo.symbol}. Required: ${required}, Current: ${avail}`);
                          }
                      }

                      if (token === 'ERC20') {
                          const isApproved = await checkAndPromptApproval();
                          if (!isApproved) {
                              throw new Error('Token approval required. Please approve before dispatching.');
                          }
                      }

                      dispatchBtnText.textContent = 'Requesting batch signature...';
                      let txHash;
                      const recipientAddresses = recipients.map(r => r.address);
                      if (token === 'ETH') {
                          const totalValue = totalAmountBN;
                          txHash = await writeContract(wagmiConfig, {
                              ...batchContract,
                              functionName: 'disperseEther',
                              args: [recipientAddresses, amounts],
                              value: totalValue,
                          });
                      } else {
                          txHash = await writeContract(wagmiConfig, {
                              ...batchContract,
                              functionName: 'disperseToken',
                              args: [tokenInfo.address, recipientAddresses, amounts],
                          });
                      }
                      
                      showNotification(`Batch transaction sent! Waiting for confirmation: <a href="${BASE_EXPLORER_URL}/tx/${txHash}" target="_blank" class="font-bold underline" style="color: #582FD6;">View Tx</a>`, 'info');
                      const receipt = await waitForTransactionReceipt(wagmiConfig, { hash: txHash });
                      if (receipt.status === 'success') {
                          const message = `âœ… Success! Batch of ${recipients.length} transfers confirmed.<br>
                              <a href="${BASE_EXPLORER_URL}/tx/${receipt.transactionHash}" target="_blank" class="font-bold underline" style="color: #582FD6;">View on BaseScan</a>`;
                          showNotification(message, 'success');
                          if (window.confetti) {
                              window.confetti({ particleCount: 150, spread: 70, origin: { y: 0.6 } });
                          }
                          recipientsTextarea.value = '';
                          parseAndValidateData('', 'text');
                      } else {
                          throw new Error('Transaction reverted on chain. Please check BaseScan for details.');
                      }
                  } catch (error) {
                      console.error('Dispatch error:', error);
                      let reason = error.shortMessage || error.message || 'Unknown error';
                      if (error.data) {
                          try {
                              const decoded = decodeErrorResult({
                                  abi: CONTRACT_ABI,
                                  data: error.data
                              });
                              if (decoded) {
                                  reason = `${decoded.errorName}(${decoded.args ? decoded.args.map(arg => arg.toString()).join(', ') : ''})`;
                              }
                          } catch (decodeErr) {
                              console.error('Revert decode failed:', decodeErr);
                          }
                      }
                      const msg = error.shortMessage?.includes('rejected') ? 'Transaction rejected by user.' : `Dispatch failed: ${reason}`;
                      showNotification(msg, 'error');
                  } finally {
                      loadingSpinner.classList.add('hidden');
                      dispatchBtnText.textContent = 'Dispatch Batch';
                      document.getElementById('shieldIcon').classList.remove('hidden');
                      dispatchBtn.disabled = false;
                      await updateSummary();
                  }
              }

              function parseAndValidateData(data, type = 'text') {
                  let parsedData = [];
                  let errorCount = 0;
                  let isCSVHeader = false;
                  if (type === 'json') {
                      try {
                          parsedData = JSON.parse(data);
                          parsedData = parsedData.map(item => ({
                              address: getAddress(item.address),
                              amount: parseFloat(item.amount)
                          })).filter(item => item.address && !isNaN(item.amount) && item.amount > 0);
                      } catch (e) {
                          showNotification('Invalid JSON format. Expected array of {address, amount}.', 'error');
                          return;
                      }
                  } else {
                      const lines = data.trim().split('\n');
                      if (lines.length > 0 && (lines[0].toLowerCase().includes('address') && lines[0].toLowerCase().includes('amount'))) {
                          isCSVHeader = true;
                      }
                      const startLine = isCSVHeader ? 1 : 0;
                      for (let i = startLine; i < lines.length; i++) {
                          const line = lines[i].trim();
                          if (line === '') continue;
                          const parts = line.split(/[\s,]+/).filter(p => p.trim());
                          if (parts.length < 2) {
                              errorCount++;
                              continue;
                          }
                          let address = parts[0].trim();
                          let amountStr = parts.slice(1).join(' ').trim();
                          const amount = parseFloat(amountStr);
                          if (address && amount > 0 && !isNaN(amount)) {
                              try {
                                  address = getAddress(address);
                                  parsedData.push({ address, amount });
                              } catch (e) {
                                  errorCount++;
                              }
                          } else {
                              errorCount++;
                          }
                      }
                  }
                  state.recipients = parsedData.filter(item => item.address && item.amount > 0);
                  if (errorCount > 0) {
                      showNotification(`Parsed ${state.recipients.length} valid recipients. Ignored ${errorCount} invalid lines (check address format or amounts).`, 'info');
                  } else if (state.recipients.length > 0) {
                      showNotification(`${state.recipients.length} recipients loaded successfully.`, 'success');
                  }
                  updateSummary();
                  updatePreview();
              }

              async function updateSummary() {
                  const count = state.recipients.length;
                  const total = state.recipients.reduce((sum, item) => sum + item.amount, 0);
                  recipientCountEl.textContent = count;
                  const tokenSymbol = state.tokenInfo.symbol;
                  totalAmountEl.textContent = `${total.toFixed(4)} ${tokenSymbol}`;
                  let isReady = false;
                  if (count > 0 && total > 0 && state.isWalletConnected && state.batchContract) {
                      if (state.token === 'ERC20') {
                          const isValidToken = state.tokenInfo.address && state.tokenInfo.symbol !== 'Invalid' && state.tokenInfo.symbol !== 'ETH';
                          if (isValidToken) {
                              const isApproved = await checkAndPromptApproval();
                              isReady = isApproved;
                          } else {
                              isReady = false;
                              showNotification('Enter a valid ERC-20 contract address to proceed.', 'error');
                          }
                      } else {
                          isReady = true;
                      }
                  }
                  dispatchBtn.disabled = !isReady;
                  if (isReady && count > 0) {
                      updateStepIndicator(3);
                  } else if (state.isWalletConnected && count > 0) {
                      updateStepIndicator(2);
                  } else {
                      updateStepIndicator(1);
                  }
              }

              function updatePreview() {
                  const dataPreview = document.getElementById('dataPreview');
                  const previewTableBody = document.getElementById('previewTableBody');
                  const previewFooter = document.getElementById('previewFooter');
                  previewTableBody.innerHTML = '';
                  if (state.recipients.length > 0) {
                      dataPreview.classList.remove('hidden');
                      const previewData = state.recipients.slice(0, 5);
                      previewData.forEach(item => {
                          const row = document.createElement('tr');
                          const truncatedAddress = `${item.address.slice(0,6)}...${item.address.slice(-4)}`;
                          row.innerHTML = `<td class="p-1 font-mono">${truncatedAddress}</td><td class="p-1 font-mono text-right">${item.amount.toFixed(4)}</td>`;
                          previewTableBody.appendChild(row);
                      });
                      if (state.recipients.length > 5) {
                          previewFooter.classList.remove('hidden');
                          previewFooter.textContent = `... and ${state.recipients.length - 5} more recipients.`;
                      } else {
                          previewFooter.classList.add('hidden');
                      }
                  } else {
                      dataPreview.classList.add('hidden');
                      previewFooter.classList.add('hidden');
                  }
              }

              document.getElementById('exportListBtn').addEventListener('click', (e) => {
                  e.preventDefault();
                  if (state.recipients.length === 0) {
                      showNotification('No recipients to export.', 'error');
                      return;
                  }
                  const csvContent = 'Address,Amount\n' + state.recipients.map(r => `${r.address},${r.amount}`).join('\n');
                  const blob = new Blob([csvContent], { type: 'text/csv' });
                  const url = URL.createObjectURL(blob);
                  const a = document.createElement('a');
                  a.href = url;
                  a.download = 'farsend-recipients.csv';
                  a.click();
                  URL.revokeObjectURL(url);
                  showNotification('Recipients exported as CSV.', 'success');
              });

              connectWalletBtn.addEventListener('click', handleConnect);
              approveBtn.addEventListener('click', handleApprove);
              dispatchBtn.addEventListener('click', handleDispatch);
              farcasterConnectBtn.addEventListener('click', () => {
                  showNotification('Farcaster Sign-in POC: In a production app, this would initiate a SIWF (Sign-In with Farcaster) flow via your wallet. Identity linked!', 'info');
                  document.getElementById('farcasterBtnText').textContent = 'Farcaster ID Linked!';
                  farcasterConnectBtn.classList.remove('bg-blue-500', 'hover:bg-blue-600');
                  farcasterConnectBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                  farcasterConnectBtn.disabled = true;
              });
              tokenSelect.addEventListener('change', () => {
                  tokenSelect.classList.add('animate-bounce');
                  setTimeout(() => tokenSelect.classList.remove('animate-bounce'), 400);
                  state.token = tokenSelect.value;
                  if (state.token === 'ERC20') {
                      erc20InputContainer.classList.remove('hidden');
                      tokenSymbolDisplay.textContent = 'Enter Address';
                      tokenInfoRow.classList.add('hidden');
                      approvalSection.classList.add('hidden');
                      state.tokenInfo = { address: '', symbol: 'Invalid', decimals: 18, allowance: 0n, requiredAllowance: 0n };
                  } else {
                      erc20InputContainer.classList.add('hidden');
                      tokenSymbolDisplay.textContent = '';
                      tokenInfoRow.classList.add('hidden');
                      approvalSection.classList.add('hidden');
                      state.tokenInfo = { address: '', symbol: 'ETH', decimals: 18, allowance: 0n, requiredAllowance: 0n };
                  }
                  updateSummary();
              });
              let debounceTimeout;
              erc20Address.addEventListener('input', async (e) => {
                  clearTimeout(debounceTimeout);
                  debounceTimeout = setTimeout(async () => {
                      const address = e.target.value.trim();
                      if (address) {
                          await validateERC20Address(address);
                      } else {
                          tokenSymbolDisplay.textContent = 'Enter Address';
                          tokenInfoRow.classList.add('hidden');
                          approvalSection.classList.add('hidden');
                          state.tokenInfo = { address: '', symbol: 'Invalid', decimals: 18, allowance: 0n, requiredAllowance: 0n };
                          await updateSummary();
                      }
                  }, 500);
              });
              recipientsTextarea.addEventListener('input', () => parseAndValidateData(recipientsTextarea.value, 'text'));
              csvUpload.addEventListener('change', (event) => {
                  const file = event.target.files[0];
                  if (!file) return;
                  const reader = new FileReader();
                  reader.onload = (e) => {
                      recipientsTextarea.value = e.target.result;
                      let fileType = 'text';
                      if (file.name.endsWith('.csv')) { fileType = 'text'; }
                      else if (file.name.endsWith('.json')) { fileType = 'json'; }
                      parseAndValidateData(e.target.result, fileType);
                  };
                  reader.readAsText(file);
              });

              updateStepIndicator(state.currentStep);
          })();
      });
    </script>
</body>
</html>
