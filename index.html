<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FarSend - Private Batch Sender</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Ethers.js removed; switching to Wagmi/viem for Farcaster integration -->
    <!-- Crypto-JS for FHE Proof-of-Concept (client-side encryption) -->
    <script defer src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.2.0/crypto-js.min.js"></script>
    <!-- Canvas Confetti for celebrations -->
    <script defer src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.3/dist/confetti.browser.min.js"></script>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">

    <!-- Farcaster Mini App Metadata -->
    <meta name="fc:miniapp" content='{
      "version":"1",
      "imageUrl":"https://farsend.example.com/image.png", // Replace with your image URL
      "button":{
        "title":"FarSend",
        "action":{
          "type":"launch_miniapp",
          "name":"SEND",
          "url":"https://farsend.example.com", // Replace with your app URL
          "splashImageUrl":"https://farsend.example.com/splash.png", // Replace with splash image
          "splashBackgroundColor":"#6A3CFF"
        }
      }
    }'>

    <style>
        /* Define Farcaster Primary Color */
        :root {
            --fc-primary: linear-gradient(90deg, #6A3CFF, #A26BFF);
            --fc-primary-hover: linear-gradient(90deg, #582FD6, #8B5CF6);
            --fc-light-bg: #F3EFFF;
            --fc-text: #1F2937; /* Gray 800 */
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: #f9fafb; /* Very light background */
        }

        .main-card {
            background-color: #ffffff;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.08);
            border: 1px solid #E5E7EB; 
        }

        .btn-primary {
            background: var(--fc-primary);
            box-shadow: 0 4px 15px rgba(106, 60, 255, 0.4);
            color: white;
        }
        .btn-primary:hover {
            background: var(--fc-primary-hover);
            box-shadow: 0 0 12px rgba(162, 107, 255, 0.6);
        }
        .btn-primary:disabled {
            background: #E5E7EB;
            color: #9CA3AF;
            cursor: not-allowed;
            opacity: 1;
            box-shadow: none;
        }
        
        /* Focus/Active styles */
        .input-focus:focus {
             border-color: #6A3CFF !important;
             box-shadow: 0 0 12px rgba(106, 60, 255, 0.4) !important;
             transition: box-shadow 0.2s ease;
        }

        /* Custom scrollbar */
        textarea::-webkit-scrollbar, .overflow-auto::-webkit-scrollbar { width: 8px; }
        textarea::-webkit-scrollbar-track, .overflow-auto::-webkit-scrollbar-track { background: #F3F4F6; }
        textarea::-webkit-scrollbar-thumb, .overflow-auto::-webkit-scrollbar-thumb { background: #6A3CFF; border-radius: 10px; }
        textarea::-webkit-scrollbar-thumb:hover, .overflow-auto::-webkit-scrollbar-thumb:hover { background: #582FD6; }

        /* Notification Toast styles */
        #notification {
            transition: opacity 0.5s ease, transform 0.5s ease;
            opacity: 0;
            transform: translateY(20px);
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(20px);
            z-index: 50;
        }
        #notification.show {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        /* Animated Gradient Header */
        @keyframes gradient-x {
          0%, 100% { background-position: 0% 50%; }
          50% { background-position: 100% 50%; }
        }
        .animate-gradient-x {
          background-size: 200% 200%;
          animation: gradient-x 6s ease infinite;
        }

        /* Stepper Progress Bar */
        #stepIndicator .flex-1.h-0\.5.bg-gray-200.mt-4.mx-2 {
          background: var(--fc-primary);
        }
    </style>
</head>
<body class="text-gray-900 min-h-screen flex items-center justify-center p-4">

    <div class="w-full max-w-2xl mx-auto">
        <!-- Header -->
        <header class="text-center mb-8">
            <div class="flex justify-center items-center mb-2">
                <h1 class="text-5xl font-extrabold tracking-tight bg-gradient-to-r from-[#6A3CFF] via-[#A26BFF] to-[#00E7FF] text-transparent bg-clip-text animate-gradient-x">FarSend</h1>
            </div>
            <p class="text-gray-600 mt-2">Send ETH & ERC-20s to multiple addresses, securely on Base.</p>
        </header>

        <!-- Main App Interface -->
        <main class="main-card rounded-2xl p-6 md:p-8 space-y-6">
            
            <!-- Progress Stepper UI Component -->
            <div id="stepIndicator" class="flex justify-between items-start mb-8 pb-4 border-b border-gray-100">
                <div class="flex flex-col items-center flex-1 min-w-0">
                    <div id="stepCircle1" class="w-8 h-8 flex items-center justify-center rounded-full transition-all duration-300" style="background-color: #6A3CFF; color: white; border-color: #6A3CFF; ring-color: #6A3CFF;">
                        <span class="font-bold">1</span>
                    </div>
                    <span id="stepLabel1" class="text-xs mt-2 text-center font-semibold" style="color: #6A3CFF;">Connect Wallet</span>
                </div>
                <div class="flex-1 h-0.5 bg-gray-200 mt-4 mx-2"></div>
                
                <div class="flex flex-col items-center flex-1 min-w-0">
                    <div id="stepCircle2" class="w-8 h-8 flex items-center justify-center rounded-full bg-gray-200 text-gray-500 transition-all duration-300">
                        <span class="font-bold">2</span>
                    </div>
                    <span id="stepLabel2" class="text-xs mt-2 text-center text-gray-500">Define Recipients</span>
                </div>
                <div class="flex-1 h-0.5 bg-gray-200 mt-4 mx-2"></div>

                <div class="flex flex-col items-center flex-1 min-w-0">
                    <div id="stepCircle3" class="w-8 h-8 flex items-center justify-center rounded-full bg-gray-200 text-gray-500 transition-all duration-300">
                        <span class="font-bold">3</span>
                    </div>
                    <span id="stepLabel3" class="text-xs mt-2 text-center text-gray-500">Dispatch</span>
                </div>
            </div>
            
            <!-- Step 1: Wallet Connection & Farcaster POC -->
            <div class="flex flex-col space-y-3 py-2">
                <!-- Wallet Button -->
                <div class="flex justify-between items-center">
                    <h2 class="text-lg font-semibold text-gray-800">Wallet</h2>
                    <button id="connectWalletBtn" class="w-48 bg-gray-200 hover:bg-gray-300 text-gray-700 font-semibold py-2 px-4 rounded-lg transition-colors duration-300 flex items-center justify-center space-x-2">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 9V7a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2m2 4h10a2 2 0 002-2v-6a2 2 0 00-2-2H9a2 2 0 00-2 2v6a2 2 0 002 2zm7-5a2 2 0 11-4 0 2 2 0 014 0z"></path></svg>
                        <span>Connect Wallet</span>
                    </button>
                </div>
                <!-- Farcaster POC Button -->
                <div class="flex justify-between items-center pt-2 border-t border-gray-100">
                    <h2 class="text-lg font-semibold text-gray-800">Farcaster ID (Optional)</h2>
                    <button id="farcasterConnectBtn" class="w-48 bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 px-4 rounded-lg transition-colors duration-300 flex items-center justify-center space-x-2 disabled:opacity-50 disabled:cursor-not-allowed">
                        <svg class="w-5 h-5" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M18.784 11.232c-.524-.717-1.12-1.385-1.782-2.003L12 3.12 7.004 9.172c-.662.618-1.258 1.286-1.782 2.003-.574.786-.872 1.696-.872 2.656 0 1.986.812 3.844 2.22 5.188 1.408 1.344 3.328 2.084 5.346 2.084 2.018 0 3.938-.74 5.346-2.084 1.408-1.344 2.22-3.202 2.22-5.188 0-.96-.298-1.87-.872-2.656zm-6.784 8.768c-1.334 0-2.586-.534-3.52-1.48s-1.48-2.186-1.48-3.52c0-.68.12-1.34.354-1.966.234-.626.586-1.206 1.054-1.724L12 6.072l6.596 6.54c.468.518.82 1.098 1.054 1.724.234.626.354 1.286.354 1.966 0 1.334-.534 2.586-1.48 3.52s-2.186 1.48-3.52 1.48z" fill="white"/></svg>
                        <span id="farcasterBtnText">Link Farcaster ID</span>
                    </button>
                </div>
            </div>
            
            <div id="app-content" class="hidden space-y-6">
                
                <!-- Separator -->
                <div class="h-px bg-gray-100"></div>

                <!-- Step 2: Token & Recipients -->
                <div>
                    <h2 class="text-lg font-semibold text-gray-800 mb-4">Define Token & Recipients</h2>
                    
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div>
                            <label for="tokenSelect" class="block text-sm font-medium text-gray-600 mb-1">Asset Type</label>
                            <select id="tokenSelect" class="w-full bg-gray-50 border border-gray-300 rounded-lg p-2.5 input-focus outline-none transition duration-150">
                                <option value="ETH">ETH (on Base)</option>
                                <option value="ERC20">ERC-20 Token</option>
                            </select>
                        </div>
                        <div id="erc20InputContainer" class="hidden">
                             <label for="erc20Address" class="block text-sm font-medium text-gray-600 mb-1">Token Contract Address</label>
                            <div class="relative">
                                <input type="text" id="erc20Address" placeholder="0x..." class="w-full bg-gray-50 border border-gray-300 rounded-lg p-2.5 pr-20 input-focus outline-none transition duration-150">
                                <span id="tokenSymbolDisplay" class="absolute right-0 top-0 h-full flex items-center pr-3 text-xs text-gray-500 font-medium"></span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="mt-6">
                        <label for="recipients" class="block text-sm font-medium text-gray-600 mb-1">Recipients & Amounts</label>
                        <textarea id="recipients" rows="6" class="w-full bg-gray-50 border border-gray-300 rounded-lg p-3 text-sm input-focus outline-none transition duration-150 text-gray-900" placeholder="Enter one address and amount per line, separated by a comma or space.&#10;e.g.,&#10;0xAb5801a7D398351b8bE11C439e05C5B3259aeC9B, 1.5&#10;0x5B38Da6a701c568545dCfcB03FcB875f56beddC4 10.75"></textarea>
                        
                        <div class="flex justify-end text-xs text-gray-500 mt-2 space-x-4">
                             <a href="#" id="exportListBtn" class="cursor-pointer font-medium hover:underline" style="color: #6A3CFF;">Export List (.csv)</a>
                            <span>Or, <label for="csvUpload" class="cursor-pointer font-medium hover:underline" style="color: #6A3CFF;">upload a file</label></span>
                            <input type="file" id="csvUpload" class="hidden" accept=".csv, .txt, .json">
                        </div>
                    </div>
                     
                     <!-- CSV/JSON Preview -->
                    <div id="dataPreview" class="hidden mt-4">
                        <h4 class="text-sm font-medium text-gray-600 mb-2">Data Preview</h4>
                        <div class="main-card rounded-lg p-3 max-h-32 overflow-auto text-xs border border-gray-200">
                            <table class="w-full">
                                <thead>
                                    <tr class="text-left text-gray-500 sticky top-0 bg-white">
                                        <th class="p-1 font-semibold">Address</th>
                                        <th class="p-1 font-semibold text-right">Amount</th>
                                    </tr>
                                </thead>
                                <tbody id="previewTableBody" class="text-gray-800"></tbody>
                            </table>
                        </div>
                        <p id="previewFooter" class="text-xs text-gray-500 mt-2 hidden"></p>
                    </div>
                </div>

                <!-- Separator -->
                <div class="h-px bg-gray-100"></div>
                
                <!-- ERC-20 Approval Step -->
                <div id="approvalSection" class="p-4 bg-yellow-50 rounded-lg border border-yellow-200 hidden">
                    <p class="text-sm text-yellow-800 mb-3 font-semibold flex items-center">
                        <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path></svg>
                        Token Approval Required
                    </p>
                    <p id="approvalMessage" class="text-sm text-yellow-700"></p>
                    <button id="approveBtn" class="w-full mt-3 bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-2 px-4 rounded-lg transition-colors duration-300">
                        Approve <span id="approveAmount">0.00</span> <span id="approveSymbol">Token</span>
                    </button>
                </div>


                <!-- Step 3: Summary & Dispatch -->
                <div id="dispatchSection">
                    <h2 class="text-lg font-semibold text-gray-800 mb-3">Review & Dispatch</h2>
                    <!-- Summary Card -->
                    <div class="bg-gray-50 rounded-lg p-4 space-y-3 text-sm border border-gray-200">
                        <div class="flex justify-between items-center">
                            <span class="text-gray-600">Total Recipients:</span>
                            <span id="recipientCount" class="font-mono font-bold text-gray-900">0</span>
                        </div>
                        <div class="flex justify-between items-center">
                            <span class="text-gray-600">Total Amount:</span>
                            <span id="totalAmount" class="font-mono font-bold text-gray-900">0.00</span>
                        </div>
                         <div id="tokenInfoRow" class="hidden flex justify-between items-center">
                            <span class="text-gray-600">Token Contract:</span>
                            <span id="tokenContractDisplay" class="font-mono text-xs font-bold text-gray-900"></span>
                        </div>
                        <div class="flex justify-between items-center pt-2 border-t border-gray-100">
                            <span class="text-gray-600">Transaction Type:</span>
                            <span class="font-bold text-gray-900">Encrypted Batch Send</span>
                        </div>
                    </div>
                    
                    <!-- Dispatch Button -->
                    <button id="dispatchBtn" disabled class="w-full mt-6 btn-primary font-bold py-3 px-4 rounded-lg transition-transform transform hover:scale-[1.01] duration-300 flex items-center justify-center space-x-3">
                        <svg id="shieldIcon" class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 20.944A12.02 12.02 0 0012 22a12.02 12.02 0 009-1.056h.001c.34.34.71.656 1.088.943l.044.032c.29.213.636.35.995.396V20.944c0-2.042-.393-4.005-1.12-5.786z"></path></svg>
                        <span id="dispatchBtnText">Dispatch Secure Batch</span>
                        <div id="loadingSpinner" class="hidden animate-spin rounded-full h-5 w-5 border-b-2 border-white"></div>
                    </button>
                    <p class="text-xs text-center text-gray-500 mt-2">Transaction data is protected by a client-side encryption Proof-of-Concept.</p>
                    <p class="text-xs text-center text-gray-500 mt-2">Privacy: Standard transparency (public on-chain). FHE privacy layer coming Q1 2026 when Zama Protocol expands to Base. Try Zama FHE Sepolia testnet <a href="https://farsend.vercel.app/sepolia" target="_blank" class="underline" style="color: #6A3CFF;">here</a>.</p>
                </div>
            </div>
        </main>
        
        <!-- Footer -->
        <footer class="text-center text-sm mt-8 bg-gradient-to-r from-[#6A3CFF] to-[#A26BFF] text-white p-4 rounded-lg shadow-md">
            <p>Built for the Farcaster + Base ecosystem.</p>
            <p><a href="https://farcaster.xyz/dare1.eth" target="_blank" class="underline">dare1.eth</a></p>
            <p>&copy; 2025 FarSend</p>
        </footer>
    </div>
    
    <!-- Notification Area -->
    <div id="notification" class="p-4 rounded-lg text-sm main-card shadow-lg" style="border: 1px solid #A98EFF;"></div>

    <!-- Farcaster SDK -->
    <script type="module">
      import { sdk } from 'https://esm.sh/@farcaster/miniapp-sdk';
      sdk.actions.ready({ disableNativeGestures: true });
    </script>

    <!-- Wagmi + Base Logic (Replaces ethers.js) -->
    <script type="module">
      import {
        createConfig,
        connect,
        disconnect,
        writeContract,
        readContract,
        http,
        waitForTransactionReceipt,
        watchAccount
      } from 'https://esm.sh/@wagmi/core';
      import { base } from 'https://esm.sh/@wagmi/core/chains';
      import { farcasterMiniApp } from 'https://esm.sh/@farcaster/miniapp-wagmi-connector';
      import { injected } from 'https://esm.sh/@wagmi/connectors';
      import { parseEther, parseUnits, getAddress, Interface } from 'https://esm.sh/viem';

      // Wait for all deferred scripts to load before initializing
      window.addEventListener('load', async () => {
          // Check if required libraries are loaded
          if (typeof window.CryptoJS === 'undefined') {
              console.error('CryptoJS not loaded');
              return;
          }

          // Use an IIFE for encapsulation and to use async/await
          (async () => {
              // --- CONSTANTS & CONFIGURATION ---
              const { CryptoJS } = window;
              const BASE_CHAIN_ID = 8453; // Base Mainnet (number for wagmi/viem)
              const BASE_EXPLORER_URL = 'https://basescan.org';

              // Load Base Contract Config (with localStorage caching)
              let CONTRACT_ADDRESS, CONTRACT_ABI;
              const cacheKey = 'farsend-base-config';
              const cached = localStorage.getItem(cacheKey);
              if (cached) {
                  try {
                      const cfg = JSON.parse(cached);
                      CONTRACT_ADDRESS = cfg.address;
                      CONTRACT_ABI = cfg.abi;
                      console.log('âœ… Loaded BaseBatchSender from cache:', CONTRACT_ADDRESS);
                  } catch (e) {
                      console.warn('Cache invalid, fetching fresh config');
                  }
              }
              if (!CONTRACT_ADDRESS) {
                  try {
                      const res = await fetch('base.json');
                      if (!res.ok) throw new Error(`HTTP ${res.status}: Failed to fetch base.json`);
                      const cfg = await res.json();
                      CONTRACT_ADDRESS = cfg.address;
                      CONTRACT_ABI = cfg.abi;
                      localStorage.setItem(cacheKey, JSON.stringify(cfg));
                      console.log('âœ… Loaded BaseBatchSender:', CONTRACT_ADDRESS);
                  } catch (e) {
                      console.error('âŒ Failed loading base.json:', e);
                      // Proceed with error handling in dispatch
                  }
              }
              
              // Minimal ABI for ERC-20 interaction
              const ERC20_ABI = [
                  "function name() view returns (string)",
                  "function symbol() view returns (string)",
                  "function decimals() view returns (uint8)",
                  "function allowance(address owner, address spender) view returns (uint256)",
                  "function approve(address spender, uint256 amount) returns (bool)",
              ];

              // Detect if running in Farcaster Mini App (sdk available after import)
              let isMiniApp = false;
              let farcasterSdk;
              try {
                  farcasterSdk = sdk; // From the imported sdk
                  if (farcasterSdk && typeof farcasterSdk.actions.ready === 'function') {
                      isMiniApp = true;
                      console.log('âœ… Running in Farcaster Mini App');
                  }
              } catch (e) {
                  console.log('Not in Farcaster Mini App');
              }

              // Optional: Prompt to add app if in mini app and not prompted
              if (isMiniApp) {
                  const hasPromptedAddApp = sessionStorage.getItem('hasPromptedAddApp');
                  if (!hasPromptedAddApp && farcasterSdk?.actions?.addMiniApp) {
                      try {
                          await farcasterSdk.actions.addMiniApp();
                      } catch (_) {}
                      sessionStorage.setItem('hasPromptedAddApp', 'true');
                  }
              }

              // Wagmi Config: Use Farcaster connector if in mini app, else injected (MetaMask)
              const connectors = [];
              if (isMiniApp) {
                  connectors.push(farcasterMiniApp(farcasterSdk));
              } else {
                  connectors.push(injected());
              }

              const wagmiConfig = createConfig({
                  chains: [base],
                  connectors,
                  transports: {
                      [base.id]: http(),
                  },
              });

              // --- DOM Elements ---
              const connectWalletBtn = document.getElementById('connectWalletBtn');
              const farcasterConnectBtn = document.getElementById('farcasterConnectBtn');
              const appContent = document.getElementById('app-content');
              const tokenSelect = document.getElementById('tokenSelect');
              const erc20InputContainer = document.getElementById('erc20InputContainer');
              const erc20Address = document.getElementById('erc20Address');
              const tokenSymbolDisplay = document.getElementById('tokenSymbolDisplay');
              const recipientsTextarea = document.getElementById('recipients');
              const csvUpload = document.getElementById('csvUpload');
              const recipientCountEl = document.getElementById('recipientCount');
              const totalAmountEl = document.getElementById('totalAmount');
              const tokenContractDisplay = document.getElementById('tokenContractDisplay');
              const tokenInfoRow = document.getElementById('tokenInfoRow');
              const dispatchBtn = document.getElementById('dispatchBtn');
              const dispatchBtnText = document.getElementById('dispatchBtnText');
              const loadingSpinner = document.getElementById('loadingSpinner');
              const notification = document.getElementById('notification');
              const approvalSection = document.getElementById('approvalSection');
              const approveBtn = document.getElementById('approveBtn');
              const approvalMessage = document.getElementById('approvalMessage');
              const approveAmountEl = document.getElementById('approveAmount');
              const approveSymbolEl = document.getElementById('approveSymbol');

              // --- APPLICATION STATE (Web3 & App) ---
              const state = {
                  isWalletConnected: false,
                  walletAddress: null,
                  batchContract: CONTRACT_ADDRESS ? { address: CONTRACT_ADDRESS, abi: CONTRACT_ABI } : null,
                  recipients: [],
                  token: 'ETH',
                  tokenInfo: {
                      address: '',
                      symbol: 'ETH',
                      decimals: 18,
                      allowance: 0n,
                      requiredAllowance: 0n,
                  },
                  currentStep: 1,
              };

              // --- HELPER FUNCTIONS ---

              function showNotification(message, type = 'success') {
                  const icons = { success: 'âœ…', error: 'âŒ', info: 'ðŸ’¡' };
                  notification.innerHTML = `${icons[type] || ''} ${message}`;
                  notification.className = 'p-4 rounded-lg text-sm main-card shadow-lg show'; 
                  
                  if (type === 'success') {
                      notification.style.backgroundColor = '#d1fae5';
                      notification.style.color = '#065f46';
                      notification.style.border = '1px solid #34d399';
                  } else if (type === 'error') {
                      notification.style.backgroundColor = '#fee2e2';
                      notification.style.color = '#991b1b';
                      notification.style.border = '1px solid #f87171';
                  } else { // info/loading
                      notification.style.backgroundColor = '#DBEAFE';
                      notification.style.color = '#1E40AF';
                      notification.style.border = '1px solid #93C5FD';
                  }
                  setTimeout(() => notification.classList.remove('show'), 8000);
              }

              function updateStepIndicator(step) {
                  state.currentStep = step;
                  const steps = [
                      { id: 'stepCircle1', labelId: 'stepLabel1', label: 'Connect Wallet' },
                      { id: 'stepCircle2', labelId: 'stepLabel2', label: 'Define Recipients' },
                      { id: 'stepCircle3', labelId: 'stepLabel3', label: 'Dispatch' }
                  ];

                  steps.forEach((s, index) => {
                      const stepEl = document.getElementById(s.id);
                      const labelEl = document.getElementById(s.labelId);
                      const isActive = (index + 1) === step;
                      const isCompleted = (index + 1) < step;

                      stepEl.className = 'w-8 h-8 flex items-center justify-center rounded-full transition-all duration-300';
                      labelEl.className = 'text-xs mt-2 text-center transition-colors duration-300';
                      
                      if (isActive) {
                          stepEl.style.backgroundColor = '#6A3CFF';
                          stepEl.style.color = 'white';
                          stepEl.classList.add('ring-4', 'ring-opacity-50');
                          stepEl.style.setProperty('ring-color', '#6A3CFF');
                          labelEl.classList.add('font-semibold');
                          labelEl.style.color = '#6A3CFF';
                      } else if (isCompleted) {
                          stepEl.style.backgroundColor = 'var(--fc-light-bg)';
                          stepEl.style.color = '#6A3CFF';
                          stepEl.classList.remove('ring-4', 'ring-opacity-50');
                          labelEl.style.color = '#582FD6';
                          labelEl.classList.add('font-medium');
                      } else {
                          stepEl.style.backgroundColor = '#E5E7EB';
                          stepEl.style.color = '#6B7280';
                          stepEl.classList.remove('ring-4', 'ring-opacity-50');
                          labelEl.style.color = '#6B7280';
                          labelEl.classList.remove('font-semibold');
                      }
                  });
              }

              // Client-side encryption POC (Simplified AES for metadata; real FHE would use Zama SDK)
              function encryptRecipients(recipient) {
                  const dataString = JSON.stringify(recipients.map(r => ({
                      a: r.address.toLowerCase(), // address
                      v: r.amount.toString(),     // value
                  })));
                  
                  // NOTE: In a real FHE scenario, this key would be managed off-chain or by a trusted third party.
                  // For this POC, we use a simple, fixed key. Replace with dynamic key derivation for security.
                  const secretKey = 'farsend-private-key-poc'; 
                  
                  const ciphertext = CryptoJS.AES.encrypt(dataString, secretKey).toString();
                  return ciphertext;
              }

              // --- WEB3 CORE LOGIC (Updated for Wagmi/viem) ---

              async function checkAndSwitchChain() {
                  try {
                      const chainId = wagmiConfig.state.chainId;
                      if (chainId !== BASE_CHAIN_ID) {
                          showNotification('Wallet is on the wrong network. Switching to Base Mainnet...', 'info');
                          await wagmiConfig.switchChain({ chainId: BASE_CHAIN_ID });
                      }
                  } catch (error) {
                      showNotification('Please manually switch your wallet to Base Mainnet (Chain ID 8453).', 'error');
                      throw new Error("Wrong network");
                  }
              }

              async function handleConnect() {
                  connectWalletBtn.disabled = true;
                  connectWalletBtn.innerHTML = `<span class="animate-pulse text-purple-700 font-bold">Connecting...</span>`;
                  
                  try {
                      const connector = wagmiConfig.connectors[0]; // First connector (Farcaster or injected)
                      const result = await connect(wagmiConfig, { connector });
                      state.walletAddress = result.accounts[0];
                      
                      await checkAndSwitchChain(); // Ensure we are on Base

                      state.isWalletConnected = true;
                      const truncatedAddress = `${state.walletAddress.slice(0, 6)}...${state.walletAddress.slice(-4)}`;
                      
                      connectWalletBtn.innerHTML = `<span>Connected: ${truncatedAddress}</span>`;
                      connectWalletBtn.classList.remove('bg-gray-200', 'hover:bg-gray-300', 'text-gray-700');
                      connectWalletBtn.classList.add('bg-green-500', 'hover:bg-green-600', 'text-white');
                      connectWalletBtn.disabled = false;
                      
                      appContent.classList.remove('hidden');
                      farcasterConnectBtn.disabled = false; // Enable Farcaster linking after wallet connect
                      updateStepIndicator(2);
                      
                      showNotification(`Wallet connected on Base: ${truncatedAddress}`, 'success');

                      // Watch for account changes
                      watchAccount(wagmiConfig, {
                          onChange(account) {
                              if (account.address && account.isConnected) {
                                  console.log('Account changed to:', account.address);
                                  state.walletAddress = account.address;
                                  const truncatedAddress = `${state.walletAddress.slice(0, 6)}...${state.walletAddress.slice(-4)}`;
                                  connectWalletBtn.innerHTML = `<span>Connected: ${truncatedAddress}</span>`;
                                  showNotification('Account changed.', 'info');
                                  updateSummary();
                              } else if (!account.isConnected && state.walletAddress) {
                                  handleDisconnect();
                                  showNotification('Wallet disconnected.', 'warning');
                              }
                          }
                      });

                  } catch (error) {
                      console.error('Connection error:', error);
                      showNotification(`Wallet connection failed: ${error.message.substring(0, 100)}`, 'error');
                      connectWalletBtn.innerHTML = `
                          <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 9V7a2 0 00-2-2H5a2 0 00-2 2v6a2 2 0 002 2h2m2 4h10a2 2 0 002-2v-6a2 0 00-2-2H9a2 0 00-2 2v6a2 2 0 002 2zm7-5a2 2 0 11-4 0 2 2 0 014 0z"></path></svg>
                          <span>Connect Wallet</span>`;
                      connectWalletBtn.disabled = false;
                  }
              }
              
              async function handleDisconnect() {
                  await disconnect(wagmiConfig);
                  state.isWalletConnected = false;
                  state.walletAddress = null;
                  
                  // Reset token info
                  state.tokenInfo = { address: '', symbol: 'ETH', decimals: 18, allowance: 0n, requiredAllowance: 0n };
                  erc20Address.value = '';
                  tokenSymbolDisplay.textContent = '';
                  approvalSection.classList.add('hidden');
                  
                  connectWalletBtn.innerHTML = `
                      <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 9V7a2 0 00-2-2H5a2 0 00-2 2v6a2 2 0 002 2h2m2 4h10a2 2 0 002-2v-6a2 0 00-2-2H9a2 0 00-2 2v6a2 2 0 002 2zm7-5a2 2 0 11-4 0 2 2 0 014 0z"></path></svg>
                      <span>Connect Wallet</span>`;
                  connectWalletBtn.classList.remove('bg-green-500', 'hover:bg-green-600', 'text-white');
                  connectWalletBtn.classList.add('bg-gray-200', 'hover:bg-gray-300', 'text-gray-700');
                  
                  farcasterConnectBtn.disabled = true;
                  appContent.classList.add('hidden');
                  updateStepIndicator(1);
              }

              async function validateERC20Address(address) {
                  try {
                      const tokenContract = { address, abi: ERC20_ABI };
                      
                      const [symbol, decimals] = await Promise.all([
                          readContract(wagmiConfig, { ...tokenContract, functionName: 'symbol' }),
                          readContract(wagmiConfig, { ...tokenContract, functionName: 'decimals' })
                      ]);

                      state.tokenInfo = {
                          address: getAddress(address),
                          symbol,
                          decimals: Number(decimals),
                          allowance: 0n,
                          requiredAllowance: 0n,
                      };

                      tokenSymbolDisplay.textContent = state.tokenInfo.symbol;
                      tokenContractDisplay.textContent = `${state.tokenInfo.address.slice(0, 6)}...${state.tokenInfo.address.slice(-4)}`;
                      tokenInfoRow.classList.remove('hidden');
                      showNotification(`Token validated: ${state.tokenInfo.symbol} (${state.tokenInfo.decimals} decimals)`, 'success');
                      return true;
                  } catch (error) {
                      console.error('ERC-20 validation failed:', error);
                      state.tokenInfo = { address: '', symbol: 'ETH', decimals: 18, allowance: 0n, requiredAllowance: 0n };
                      tokenSymbolDisplay.textContent = 'Invalid';
                      tokenInfoRow.classList.add('hidden');
                      showNotification('Invalid ERC-20 contract address or network error.', 'error');
                      return false;
                  }
              }

              async function checkAndPromptApproval() {
                  // If not an ERC20 token, no approval needed
                  if (state.token !== 'ERC20' || !state.tokenInfo.address || !CONTRACT_ADDRESS) {
                      approvalSection.classList.add('hidden');
                      return true;
                  }
                  
                  // Calculate total amount in BigInt (smallest unit)
                  const totalAmountDecimal = state.recipients.reduce((sum, r) => sum + r.amount, 0);
                  const totalAmountBN = parseUnits(totalAmountDecimal.toString(), state.tokenInfo.decimals);
                  
                  state.tokenInfo.requiredAllowance = totalAmountBN;
                  
                  try {
                      const allowance = await readContract(wagmiConfig, {
                          address: state.tokenInfo.address,
                          abi: ERC20_ABI,
                          functionName: 'allowance',
                          args: [state.walletAddress, CONTRACT_ADDRESS],
                      });
                      state.tokenInfo.allowance = allowance;

                      if (allowance >= totalAmountBN) {
                          approvalSection.classList.add('hidden');
                          return true; // Already approved enough
                      } else {
                          // Display approval prompt
                          const neededAmount = totalAmountBN - allowance;
                          const neededAmountFormatted = ethers.formatUnits(neededAmount, state.tokenInfo.decimals);

                          approveAmountEl.textContent = totalAmountDecimal.toFixed(state.tokenInfo.decimals > 4 ? 4 : state.tokenInfo.decimals);
                          approveSymbolEl.textContent = state.tokenInfo.symbol;
                          approvalMessage.textContent = `The batch sender requires approval to spend ${totalAmountDecimal.toFixed(4)} ${state.tokenInfo.symbol}. Your current allowance is insufficient.`;
                          approvalSection.classList.remove('hidden');
                          
                          return false; // Approval needed
                      }
                  } catch (error) {
                      console.error('Allowance check failed:', error);
                      showNotification('Failed to check token allowance. See console for details.', 'error');
                      return false;
                  }
              }

              async function handleApprove() {
                  if (!CONTRACT_ADDRESS) {
                      showNotification('Contract address not loaded. Please refresh.', 'error');
                      return;
                  }
                  approveBtn.disabled = true;
                  approveBtn.innerHTML = 'Approving...';
                  
                  // Approve the total required amount
                  const amountToApprove = state.tokenInfo.requiredAllowance;

                  try {
                      showNotification(`Requesting approval for total batch amount of ${parseUnits(amountToApprove, state.tokenInfo.decimals)} ${state.tokenInfo.symbol}...`, 'info');
                      
                      const txHash = await writeContract(wagmiConfig, {
                          address: state.tokenInfo.address,
                          abi: ERC20_ABI,
                          functionName: 'approve',
                          args: [CONTRACT_ADDRESS, amountToApprove],
                      });
                      
                      showNotification(`Approval transaction sent. Waiting for confirmation: <a href="${BASE_EXPLORER_URL}/tx/${txHash}" target="_blank" class="font-bold underline" style="color: #582FD6;">View Tx</a>`, 'info');
                      
                      await waitForTransactionReceipt(wagmiConfig, { hash: txHash }); // Wait for 1 confirmation
                      
                      showNotification(`Approval confirmed! You can now dispatch the batch.`, 'success');
                      
                      // Update state and UI
                      state.tokenInfo.allowance = amountToApprove;
                      approvalSection.classList.add('hidden');
                      updateSummary(); // Re-enable dispatch button
                      
                  } catch (error) {
                      console.error('Approval failed:', error);
                      // Check for user rejection
                      const msg = error.shortMessage?.includes('rejected') ? 'Transaction rejected by user.' : `Approval failed: ${error.shortMessage || error.message}`;
                      showNotification(msg, 'error');
                  } finally {
                      approveBtn.disabled = false;
                      approveBtn.innerHTML = `Approve <span id="approveAmount">0.00</span> <span id="approveSymbol">Token</span>`;
                  }
              }

              // --- DISPATCH LOGIC (Updated for Wagmi/viem) ---

              async function handleDispatch() {
                  if (!state.walletAddress) return showNotification('Wallet not connected.', 'error');
                  if (!state.batchContract || !CONTRACT_ADDRESS) return showNotification('Batch contract not loaded. Please refresh the page.', 'error');

                  dispatchBtn.disabled = true;
                  loadingSpinner.classList.remove('hidden');
                  dispatchBtnText.textContent = 'Preparing batch...';
                  document.getElementById('shieldIcon').classList.add('hidden');

                  const { recipients, token, tokenInfo, batchContract, walletAddress } = state;

                  try {
                      if (recipients.length === 0) throw new Error('No recipients defined');

                      // Pre-flight checks
                      const decimals = token === 'ETH' ? 18 : tokenInfo.decimals;
                      const rawAmounts = recipients.map(r => r.amount.toString());
                      const amounts = rawAmounts.map(a => parseUnits(a, decimals));
                      const totalAmountBN = amounts.reduce((sum, amt) => sum + amt, 0n);

                      if (token === 'ETH') {
                          const balance = await wagmiConfig.publicClient.getBalance({ address: walletAddress });
                          if (totalAmountBN > balance) {
                              const required = parseEther(totalAmountBN);
                              const available = parseEther(balance);
                              throw new Error(`Insufficient ETH balance. Required: ${required} ETH, Available: ${available} ETH`);
                          }
                      } else {
                          if (!tokenInfo.address) throw new Error('Token contract not initialized');
                          const allowance = await readContract(wagmiConfig, {
                              address: tokenInfo.address,
                              abi: ERC20_ABI,
                              functionName: 'allowance',
                              args: [walletAddress, CONTRACT_ADDRESS],
                          });
                          if (allowance < totalAmountBN) {
                              const required = parseUnits(totalAmountBN, decimals);
                              const avail = parseUnits(allowance, decimals);
                              throw new Error(`Insufficient allowance for ${tokenInfo.symbol}. Required: ${required}, Current: ${avail}`);
                          }
                      }

                      // ERC-20 Approval Check (Final check before sending)
                      if (token === 'ERC20') {
                          const isApproved = await checkAndPromptApproval();
                          if (!isApproved) {
                              throw new Error('Token approval required. Please approve before dispatching.');
                          }
                      }

                      // Send transaction
                      dispatchBtnText.textContent = 'Requesting transaction signature...';
                      let txHash;
                      const recipientAddresses = recipients.map(r => r.address);

                      if (token === 'ETH') {
                          const totalValue = totalAmountBN;
                          txHash = await writeContract(wagmiConfig, {
                              ...batchContract,
                              functionName: 'disperseEther',
                              args: [recipientAddresses, amounts],
                              value: totalValue,
                          });
                      } else {
                          txHash = await writeContract(wagmiConfig, {
                              ...batchContract,
                              functionName: 'disperseToken',
                              args: [tokenInfo.address, recipientAddresses, amounts],
                          });
                      }
                      
                      // Transaction Feedback
                      showNotification(`Batch transaction sent! Waiting for confirmation: <a href="${BASE_EXPLORER_URL}/tx/${txHash}" target="_blank" class="font-bold underline" style="color: #582FD6;">View Tx</a>`, 'info');

                      // Wait for confirmation
                      const receipt = await waitForTransactionReceipt(wagmiConfig, { hash: txHash });

                      if (receipt.status === 'success') {
                           const message = `âœ… Success! Batch of ${recipients.length} transfers confirmed.<br>
                              <a href="${BASE_EXPLORER_URL}/tx/${receipt.transactionHash}" target="_blank" class="font-bold underline" style="color: #582FD6;">View on BaseScan</a>`;
                          showNotification(message, 'success');
                          
                          // Confetti celebration
                          if (window.confetti) {
                              window.confetti({ particleCount: 150, spread: 70, origin: { y: 0.6 } });
                          }
                          
                          // Reset form
                          recipientsTextarea.value = '';
                          parseAndValidateData('', 'text');

                      } else {
                          throw new Error('Transaction reverted on chain. Please check BaseScan for details.');
                      }

                  } catch (error) {
                      console.error('Dispatch error:', error);
                      let reason = error.shortMessage || error.message || 'Unknown error';
                      // Decode revert reason if present
                      if (error.data) {
                          try {
                              const iface = new Interface(CONTRACT_ABI);
                              const decoded = iface.parseError(error.data);
                              if (decoded) {
                                  reason = `${decoded.name}(${decoded.args.map(arg => arg.toString()).join(', ')})`;
                              } else if (error.data.startsWith('0x08c379a0')) {
                                  const stringData = error.data.slice(10);
                                  reason = ethers.toUtf8String('0x' + stringData);
                              }
                          } catch (decodeErr) {
                              console.error('Revert decode failed:', decodeErr);
                          }
                      }
                      const msg = error.shortMessage?.includes('rejected') ? 'Transaction rejected by user.' : `Dispatch failed: ${reason}`;
                      showNotification(msg, 'error');
                  } finally {
                      loadingSpinner.classList.add('hidden');
                      dispatchBtnText.textContent = 'Dispatch Secure Batch';
                      document.getElementById('shieldIcon').classList.remove('hidden');
                      dispatchBtn.disabled = false;
                      updateSummary(); // Re-check state which might re-disable if conditions are not met
                  }
              }


              // --- UI/Data Functions (Completed Parsing & Preview Logic) ---

              function parseAndValidateData(data, type = 'text') {
                  let parsedData = [];
                  let errorCount = 0;
                  let isCSVHeader = false;

                  if (type === 'json') {
                      try {
                          parsedData = JSON.parse(data);
                          // Assume JSON array of {address: '0x...', amount: 1.5}
                          parsedData = parsedData.map(item => ({
                              address: getAddress(item.address),
                              amount: parseFloat(item.amount)
                          })).filter(item => item.address && !isNaN(item.amount) && item.amount > 0);
                      } catch (e) {
                          showNotification('Invalid JSON format. Expected array of {address, amount}.', 'error');
                          return;
                      }
                  } else { // text or csv
                      const lines = data.trim().split('\n');
                      // Check for CSV header
                      if (lines.length > 0 && (lines[0].toLowerCase().includes('address') && lines[0].toLowerCase().includes('amount'))) {
                          isCSVHeader = true;
                      }
                      const startLine = isCSVHeader ? 1 : 0;

                      for (let i = startLine; i < lines.length; i++) {
                          const line = lines[i].trim();
                          if (line === '') continue;

                          // Split by comma or space (flexible separator)
                          const parts = line.split(/[\s,]+/).filter(p => p.trim());
                          
                          if (parts.length < 2) {
                              errorCount++;
                              continue;
                          }

                          let address = parts[0].trim();
                          let amountStr = parts.slice(1).join(' ').trim(); // Join rest for amount if multi-word

                          const amount = parseFloat(amountStr);

                          if (address && amount > 0 && !isNaN(amount)) {
                              try {
                                  address = getAddress(address); // Validates checksum
                                  parsedData.push({ address, amount });
                              } catch (e) {
                                  errorCount++;
                              }
                          } else {
                              errorCount++;
                          }
                      }
                  }
                  
                  state.recipients = parsedData.filter(item => item.address && item.amount > 0);

                  if (errorCount > 0) {
                      showNotification(`Parsed ${state.recipients.length} valid recipients. Ignored ${errorCount} invalid lines (check address format or amounts).`, 'info');
                  } else if (state.recipients.length > 0) {
                      showNotification(`${state.recipients.length} recipients loaded successfully.`, 'success');
                  }

                  updateSummary();
                  updatePreview();
              }

              async function updateSummary() {
                  const count = state.recipients.length;
                  const total = state.recipients.reduce((sum, item) => sum + item.amount, 0);
                  
                  recipientCountEl.textContent = count;
                  const tokenSymbol = state.tokenInfo.symbol;
                  totalAmountEl.textContent = `${total.toFixed(4)} ${tokenSymbol}`;
                  
                  let isReady = false;
                  
                  if (count > 0 && total > 0 && state.isWalletConnected && state.batchContract) {
                      if (state.token === 'ERC20') {
                          const isValidToken = state.tokenInfo.address && state.tokenInfo.symbol !== 'ETH';
                          if (isValidToken) {
                              // Check approval for ERC20
                              const isApproved = await checkAndPromptApproval();
                              isReady = isApproved;
                          } else {
                              // Invalid ERC20 address entered
                              isReady = false;
                              showNotification('Enter a valid ERC-20 contract address to proceed.', 'error');
                          }
                      } else {
                          // ETH is ready if connected and recipients exist
                          isReady = true;
                      }
                  }

                  dispatchBtn.disabled = !isReady;
                  if (isReady && count > 0) {
                      updateStepIndicator(3);
                  } else if (state.isWalletConnected && count > 0) {
                      updateStepIndicator(2);
                  } else {
                      updateStepIndicator(1);
                  }
              }

              function updatePreview() {
                  const dataPreview = document.getElementById('dataPreview');
                  const previewTableBody = document.getElementById('previewTableBody');
                  const previewFooter = document.getElementById('previewFooter');
                  
                  previewTableBody.innerHTML = '';
                  
                  if (state.recipients.length > 0) {
                      dataPreview.classList.remove('hidden');
                      // Show first 5 for preview
                      const previewData = state.recipients.slice(0, 5);
                      previewData.forEach(item => {
                          const row = document.createElement('tr');
                          const truncatedAddress = `${item.address.slice(0,6)}...${item.address.slice(-4)}`;
                          row.innerHTML = `<td class="p-1 font-mono">${truncatedAddress}</td><td class="p-1 font-mono text-right">${item.amount.toFixed(4)}</td>`;
                          previewTableBody.appendChild(row);
                      });
                      
                      if (state.recipients.length > 5) {
                          previewFooter.classList.remove('hidden');
                          previewFooter.textContent = `... and ${state.recipients.length - 5} more recipients.`;
                      } else {
                          previewFooter.classList.add('hidden');
                      }

                  } else {
                      dataPreview.classList.add('hidden');
                      previewFooter.classList.add('hidden');
                  }
              }

              // Export functionality (basic CSV download)
              document.getElementById('exportListBtn').addEventListener('click', (e) => {
                  e.preventDefault();
                  if (state.recipients.length === 0) {
                      showNotification('No recipients to export.', 'error');
                      return;
                  }
                  const csvContent = 'Address,Amount\n' + state.recipients.map(r => `${r.address},${r.amount}`).join('\n');
                  const blob = new Blob([csvContent], { type: 'text/csv' });
                  const url = URL.createObjectURL(blob);
                  const a = document.createElement('a');
                  a.href = url;
                  a.download = 'farsend-recipients.csv';
                  a.click();
                  URL.revokeObjectURL(url);
                  showNotification('Recipients exported as CSV.', 'success');
              });
              
              // --- EVENT LISTENERS ---

              connectWalletBtn.addEventListener('click', handleConnect);
              approveBtn.addEventListener('click', handleApprove);
              dispatchBtn.addEventListener('click', handleDispatch);

              farcasterConnectBtn.addEventListener('click', () => {
                  showNotification('Farcaster Sign-in POC: In a production app, this would initiate a SIWF (Sign-In with Farcaster) flow via your wallet. Identity linked!', 'info');
                  document.getElementById('farcasterBtnText').textContent = 'Farcaster ID Linked!';
                  farcasterConnectBtn.classList.remove('bg-blue-500', 'hover:bg-blue-600');
                  farcasterConnectBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                  farcasterConnectBtn.disabled = true;
              });

              tokenSelect.addEventListener('change', () => {
                  tokenSelect.classList.add('animate-bounce');
                  setTimeout(() => tokenSelect.classList.remove('animate-bounce'), 400);
                  state.token = tokenSelect.value;
                  if (state.token === 'ERC20') {
                      erc20InputContainer.classList.remove('hidden');
                      tokenSymbolDisplay.textContent = 'Enter Address';
                      tokenInfoRow.classList.add('hidden');
                      approvalSection.classList.add('hidden');
                      // Reset token info to force validation
                      state.tokenInfo = { address: '', symbol: 'ERC20', decimals: 18, allowance: 0n, requiredAllowance: 0n };
                  } else {
                      erc20InputContainer.classList.add('hidden');
                      tokenSymbolDisplay.textContent = '';
                      tokenInfoRow.classList.add('hidden');
                      approvalSection.classList.add('hidden');
                      state.tokenInfo = { address: '', symbol: 'ETH', decimals: 18, allowance: 0n, requiredAllowance: 0n };
                  }
                  updateSummary();
              });

              erc20Address.addEventListener('input', async (e) => {
                  const address = e.target.value.trim();
                  if (address.startsWith('0x') && address.length === 42) {
                      await validateERC20Address(address);
                  } else {
                      tokenSymbolDisplay.textContent = 'Invalid';
                      tokenInfoRow.classList.add('hidden');
                      approvalSection.classList.add('hidden');
                      state.tokenInfo = { address: '', symbol: 'ERC20', decimals: 18, allowance: 0n, requiredAllowance: 0n };
                  }
                  updateSummary();
              });

              recipientsTextarea.addEventListener('input', () => parseAndValidateData(recipientsTextarea.value, 'text'));
              csvUpload.addEventListener('change', (event) => {
                  const file = event.target.files[0];
                  if (!file) return;

                  const reader = new FileReader();
                  reader.onload = (e) => {
                      recipientsTextarea.value = e.target.result;
                      let fileType = 'text';
                      if (file.name.endsWith('.csv')) { fileType = 'text'; } // Treat as text with header check
                      else if (file.name.endsWith('.json')) { fileType = 'json'; }
                      parseAndValidateData(e.target.result, fileType);
                  };
                  reader.readAsText(file);
              });
              
              // --- INITIALIZATION ---
              updateStepIndicator(state.currentStep);
              
          })(); // End of IIFE
      });
    </script>
</body>
</html>
